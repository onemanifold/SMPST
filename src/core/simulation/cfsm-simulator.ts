/**
 * CFSM Simulator - Single Role Execution
 *
 * Implements local execution semantics for one CFSM (one role's view).
 * Based on LTS (Labeled Transition System) semantics for communicating automata.
 *
 * ============================================================================
 * FORMAL SEMANTICS
 * ============================================================================
 *
 * A CFSM is a tuple (Q, q₀, A, →, Q_f) where:
 * - Q: finite set of states
 * - q₀: initial state
 * - A: set of actions (send !p⟨l⟩, receive ?p⟨l⟩, tau τ, choice)
 * - →: transition relation Q × A × Q
 * - Q_f: final states
 *
 * Transition Enabling Rules:
 * 1. Send !p⟨l⟩: Always enabled (async send)
 * 2. Receive ?p⟨l⟩: Enabled iff message ⟨p,l⟩ in buffer
 * 3. Tau τ: Always enabled (internal action)
 * 4. Choice: Always enabled (internal decision)
 *
 * Message Buffers:
 * - One FIFO queue per sender role
 * - Messages consumed in order (FIFO semantics)
 *
 * References:
 * - Honda, Yoshida, Carbone (2008): Multiparty Asynchronous Session Types
 * - Brand & Zafiropulo (1983): On Communicating Finite-State Machines
 */

import type { CFSM, CFSMTransition } from '../projection/types';
import type {
  CFSMSimulatorConfig,
  CFSMExecutionState,
  CFSMStepResult,
  CFSMRunResult,
  Message,
  MessageBuffer,
  CFSMExecutionTrace,
  CFSMTraceEvent,
  CFSMEventType,
  CFSMEventCallback,
  CFSMExecutionSnapshot,
  CFSMExecutionHistoryConfig,
  ICFSMExecutionHistory,
} from './cfsm-simulator-types';
import { CFSMExecutionHistory } from './execution-history';

export class CFSMSimulator {
  private cfsm: CFSM;
  private config: Required<Omit<CFSMSimulatorConfig, 'executionHistory'>>;

  // Execution history (for backward stepping)
  private executionHistory: ICFSMExecutionHistory;

  // Execution state
  private currentState: string;
  private visitedStates: string[] = [];
  private stepCount: number = 0;
  private completed: boolean = false;
  private reachedMaxSteps: boolean = false;

  // Message buffer (from-role → messages)
  private buffer: MessageBuffer = { channels: new Map() };

  // Outgoing messages (generated by sends, to be delivered by coordinator)
  private outgoingMessages: Message[] = [];

  // Transition selection
  private pendingTransitionChoice: number | null = null;

  // Trace
  private trace: CFSMExecutionTrace;

  // Event subscribers
  private listeners: Map<CFSMEventType, Set<CFSMEventCallback>> = new Map();

  // Message ID counter
  private messageIdCounter: number = 0;

  constructor(cfsm: CFSM, config: CFSMSimulatorConfig = {}) {
    this.cfsm = cfsm;
    this.config = {
      maxSteps: config.maxSteps ?? 1000,
      maxBufferSize: config.maxBufferSize ?? 0, // 0 = unbounded
      recordTrace: config.recordTrace ?? false,
      transitionStrategy: config.transitionStrategy ?? 'first',
      verifyFIFO: config.verifyFIFO ?? false,
    };

    // Initialize execution history
    this.executionHistory = config.executionHistory || new CFSMExecutionHistory({
      enabled: false, // Disabled by default for performance
      maxSnapshots: 1000,
    });

    // Initialize at initial state
    this.currentState = cfsm.initialState;
    this.visitedStates.push(cfsm.initialState);

    // Initialize trace
    this.trace = {
      role: cfsm.role,
      events: [],
      startTime: Date.now(),
      totalSteps: 0,
      completed: false,
    };

    // Record initial snapshot
    this.recordSnapshot();
  }

  /**
   * Get current execution state
   */
  getState(): CFSMExecutionState {
    return {
      currentState: this.currentState,
      visitedStates: [...this.visitedStates],
      stepCount: this.stepCount,
      completed: this.completed,
      reachedMaxSteps: this.reachedMaxSteps,
      buffer: this.cloneBuffer(),
      enabledTransitions: this.getEnabledTransitions(),
      pendingTransitionChoice: this.pendingTransitionChoice,
    };
  }

  /**
   * Get enabled transitions from current state
   *
   * A transition is enabled if:
   * - Send: Always (asynchronous)
   * - Receive: Message available in buffer
   * - Tau: Always
   * - Choice: Always
   */
  getEnabledTransitions(): CFSMTransition[] {
    const transitions = this.cfsm.transitions.filter(t => t.from === this.currentState);

    return transitions.filter(t => {
      if (t.action.type === 'receive') {
        // Receive enabled only if message in buffer
        const from = t.action.from;
        const label = t.action.label;
        const queue = this.buffer.channels.get(from);
        if (!queue || queue.length === 0) return false;

        // Check if first message matches (FIFO)
        const firstMsg = queue[0];
        return firstMsg.label === label;
      }

      // Send, tau, choice always enabled
      return true;
    });
  }

  /**
   * Execute one step (fire one enabled transition)
   */
  step(): CFSMStepResult {
    this.emit('step-start', { stepCount: this.stepCount, currentState: this.currentState });

    // Check if completed
    if (this.completed) {
      const error = {
        type: 'invalid-state' as const,
        message: 'CFSM already completed',
        stateId: this.currentState,
      };
      this.emit('error', error);
      return { success: false, error, state: this.getState() };
    }

    // Check max steps
    if (this.stepCount >= this.config.maxSteps) {
      this.reachedMaxSteps = true;
      const error = {
        type: 'max-steps' as const,
        message: `Maximum steps (${this.config.maxSteps}) reached`,
        stateId: this.currentState,
      };
      this.emit('error', error);
      return { success: false, error, state: this.getState() };
    }

    // Get enabled transitions
    const enabled = this.getEnabledTransitions();

    if (enabled.length === 0) {
      // No enabled transitions - deadlock or completion
      if (this.cfsm.terminalStates.includes(this.currentState)) {
        // Reached terminal - normal completion
        this.completed = true;
        this.trace.completed = true;
        this.trace.endTime = Date.now();
        this.trace.totalSteps = this.stepCount;
        this.emit('complete', { role: this.cfsm.role, steps: this.stepCount });
        return { success: true, state: this.getState() };
      } else {
        // Deadlock - no transitions enabled and not terminal
        const error = {
          type: 'no-enabled-transitions' as const,
          message: `No enabled transitions at state ${this.currentState}`,
          stateId: this.currentState,
        };
        this.emit('deadlock', { role: this.cfsm.role, state: this.currentState });
        return { success: false, error, state: this.getState() };
      }
    }

    // Select transition to fire
    let transitionIndex: number;
    if (this.pendingTransitionChoice !== null) {
      transitionIndex = this.pendingTransitionChoice;
      this.pendingTransitionChoice = null;
    } else {
      // Auto-select based on strategy
      if (this.config.transitionStrategy === 'first') {
        transitionIndex = 0;
      } else if (this.config.transitionStrategy === 'random') {
        transitionIndex = Math.floor(Math.random() * enabled.length);
      } else {
        // Manual - require explicit selection
        const error = {
          type: 'transition-required' as const,
          message: 'Multiple transitions enabled - must call selectTransition()',
          stateId: this.currentState,
        };
        return { success: false, error, state: this.getState() };
      }
    }

    if (transitionIndex >= enabled.length) {
      const error = {
        type: 'invalid-state' as const,
        message: `Invalid transition index ${transitionIndex}`,
        stateId: this.currentState,
      };
      return { success: false, error, state: this.getState() };
    }

    const transition = enabled[transitionIndex];

    // Fire the transition
    this.stepCount++;
    const result = this.fireTransition(transition);

    this.emit('step-end', { stepCount: this.stepCount, result, state: this.getState() });

    return result;
  }

  /**
   * Fire a specific transition
   */
  private fireTransition(transition: CFSMTransition): CFSMStepResult {
    const action = transition.action;

    // Emit transition-fired event
    this.emit('transition-fired', {
      transitionId: transition.id,
      from: transition.from,
      to: transition.to,
      action,
    });

    // Execute action
    switch (action.type) {
      case 'send':
        return this.executeSend(transition);
      case 'receive':
        return this.executeReceive(transition);
      case 'tau':
        return this.executeTau(transition);
      case 'choice':
        return this.executeChoice(transition);
      default:
        throw new Error(`Unknown action type: ${(action as any).type}`);
    }
  }

  /**
   * Execute send action
   * Creates message and adds to outgoing queue
   */
  private executeSend(transition: CFSMTransition): CFSMStepResult {
    const action = transition.action;
    if (action.type !== 'send') throw new Error('Expected send action');

    // Create message(s)
    const recipients = typeof action.to === 'string' ? [action.to] : action.to;
    const messages: Message[] = recipients.map(to => ({
      id: `${this.cfsm.role}-msg-${this.messageIdCounter++}`,
      from: this.cfsm.role,
      to,
      label: action.label,
      payloadType: action.payloadType,
      timestamp: Date.now(),
    }));

    // Add to outgoing queue (coordinator will deliver)
    this.outgoingMessages.push(...messages);

    // Emit send event
    for (const msg of messages) {
      this.emit('send', {
        messageId: msg.id,
        to: msg.to,
        label: msg.label,
        payloadType: msg.payloadType,
      });

      // Record in trace
      if (this.config.recordTrace) {
        this.trace.events.push({
          type: 'send',
          timestamp: msg.timestamp,
          to: msg.to,
          label: msg.label,
          payloadType: msg.payloadType,
          messageId: msg.id,
          stateId: this.currentState,
        });
      }
    }

    // Transition to next state
    this.currentState = transition.to;
    this.visitedStates.push(this.currentState);

    // Check if reached terminal
    if (this.cfsm.terminalStates.includes(this.currentState)) {
      this.completed = true;
      this.trace.completed = true;
      this.trace.endTime = Date.now();
      this.trace.totalSteps = this.stepCount;
      this.emit('complete', { role: this.cfsm.role, steps: this.stepCount });
    }

    return {
      success: true,
      transition,
      action,
      state: this.getState(),
    };
  }

  /**
   * Execute receive action
   * Consumes message from buffer
   */
  private executeReceive(transition: CFSMTransition): CFSMStepResult {
    const action = transition.action;
    if (action.type !== 'receive') throw new Error('Expected receive action');

    // Get message from buffer (FIFO)
    const queue = this.buffer.channels.get(action.from);
    if (!queue || queue.length === 0) {
      throw new Error(`No message from ${action.from} in buffer`);
    }

    const msg = queue[0]; // Peek at head without removing yet

    // Verify FIFO property (Theorem 5.3, Honda 2016)
    const violation = this.verifyFIFOProperty(action.from, msg);
    if (violation) {
      // FIFO violation detected - return error
      return {
        success: false,
        error: {
          type: 'fifo-violation',
          message: violation.message,
          stateId: this.currentState,
          details: violation.details,
        },
        state: this.getState(),
      };
    }

    // Dequeue message (now safe after verification)
    queue.shift()!;

    // Emit receive event
    this.emit('receive', {
      messageId: msg.id,
      from: msg.from,
      label: msg.label,
      payloadType: msg.payloadType,
    });

    this.emit('buffer-dequeue', {
      from: msg.from,
      message: msg,
      remainingInQueue: queue.length,
    });

    // Record in trace
    if (this.config.recordTrace) {
      this.trace.events.push({
        type: 'receive',
        timestamp: Date.now(),
        from: action.from,
        label: action.label,
        payloadType: action.payloadType,
        messageId: msg.id,
        stateId: this.currentState,
      });
    }

    // Transition to next state
    this.currentState = transition.to;
    this.visitedStates.push(this.currentState);

    // Check if reached terminal
    if (this.cfsm.terminalStates.includes(this.currentState)) {
      this.completed = true;
      this.trace.completed = true;
      this.trace.endTime = Date.now();
      this.trace.totalSteps = this.stepCount;
      this.emit('complete', { role: this.cfsm.role, steps: this.stepCount });
    }

    return {
      success: true,
      transition,
      action,
      state: this.getState(),
    };
  }

  /**
   * Execute tau (silent) action
   */
  private executeTau(transition: CFSMTransition): CFSMStepResult {
    const action = transition.action;
    if (action.type !== 'tau') throw new Error('Expected tau action');

    this.emit('tau', { stateId: this.currentState });

    // Record in trace
    if (this.config.recordTrace) {
      this.trace.events.push({
        type: 'tau',
        timestamp: Date.now(),
        stateId: this.currentState,
      });
    }

    // Transition to next state
    this.currentState = transition.to;
    this.visitedStates.push(this.currentState);

    // Check if reached terminal
    if (this.cfsm.terminalStates.includes(this.currentState)) {
      this.completed = true;
      this.trace.completed = true;
      this.trace.endTime = Date.now();
      this.trace.totalSteps = this.stepCount;
      this.emit('complete', { role: this.cfsm.role, steps: this.stepCount });
    }

    return {
      success: true,
      transition,
      action,
      state: this.getState(),
    };
  }

  /**
   * Execute choice action
   */
  private executeChoice(transition: CFSMTransition): CFSMStepResult {
    const action = transition.action;
    if (action.type !== 'choice') throw new Error('Expected choice action');

    this.emit('choice', { branch: action.branch, stateId: this.currentState });

    // Record in trace
    if (this.config.recordTrace) {
      this.trace.events.push({
        type: 'choice',
        timestamp: Date.now(),
        branch: action.branch,
        stateId: this.currentState,
      });
    }

    // Transition to next state
    this.currentState = transition.to;
    this.visitedStates.push(this.currentState);

    // Check if reached terminal
    if (this.cfsm.terminalStates.includes(this.currentState)) {
      this.completed = true;
      this.trace.completed = true;
      this.trace.endTime = Date.now();
      this.trace.totalSteps = this.stepCount;
      this.emit('complete', { role: this.cfsm.role, steps: this.stepCount });
    }

    return {
      success: true,
      transition,
      action,
      state: this.getState(),
    };
  }

  /**
   * Deliver a message to this simulator's buffer
   * Called by distributed coordinator
   *
   * FIFO Semantics (Theorem 5.3, Honda 2016):
   * Messages are enqueued using push() to maintain send order.
   * The queue is FIFO: first message in is first message out.
   */
  deliverMessage(message: Message): void {
    const from = message.from;

    // Check buffer size limit
    if (this.config.maxBufferSize > 0) {
      const queue = this.buffer.channels.get(from) || [];
      if (queue.length >= this.config.maxBufferSize) {
        throw new Error(`Buffer overflow: ${this.cfsm.role} cannot accept message from ${from}`);
      }
    }

    // Add to buffer (maintains FIFO: push to end, shift from start)
    if (!this.buffer.channels.has(from)) {
      this.buffer.channels.set(from, []);
    }
    this.buffer.channels.get(from)!.push(message);

    this.emit('buffer-enqueue', {
      from,
      message,
      queueLength: this.buffer.channels.get(from)!.length,
    });
  }

  /**
   * Get outgoing messages (sent but not yet delivered)
   * Called by distributed coordinator
   */
  getOutgoingMessages(): Message[] {
    const messages = [...this.outgoingMessages];
    this.outgoingMessages = []; // Clear after reading
    return messages;
  }

  /**
   * Select transition manually (for manual strategy)
   */
  selectTransition(index: number): void {
    const enabled = this.getEnabledTransitions();
    if (index < 0 || index >= enabled.length) {
      throw new Error(`Invalid transition index ${index} (${enabled.length} enabled)`);
    }
    this.pendingTransitionChoice = index;
  }

  /**
   * Verify FIFO ordering property (Theorem 5.3, Honda et al. 2016)
   *
   * Theorem 5.3: For all messages (mᵢ, mⱼ) in queue Q_{p → q}:
   *   i < j ⟹ receive(mᵢ) ≺ receive(mⱼ)
   *
   * Property: Messages from sender p to receiver q must be received
   * in the exact order they were sent.
   *
   * @param channel - Sender role
   * @param messageToReceive - Message about to be received
   * @returns Violation details if FIFO violated, undefined otherwise
   */
  private verifyFIFOProperty(channel: string, messageToReceive: Message): { type: 'fifo-violation'; message: string; details: any } | undefined {
    if (!this.config.verifyFIFO) {
      return undefined; // Verification disabled
    }

    const queue = this.buffer.channels.get(channel);
    if (!queue || queue.length === 0) {
      return undefined; // Empty queue, no violation possible
    }

    // Theorem 5.3 verification:
    // The message at the head of the queue (index 0) must be the oldest (lowest timestamp)
    const headMessage = queue[0];

    // Verify that headMessage is indeed the oldest in the queue
    for (let i = 1; i < queue.length; i++) {
      if (queue[i].timestamp < headMessage.timestamp) {
        // VIOLATION: A newer message (at index i) has an earlier timestamp
        // This violates FIFO ordering
        return {
          type: 'fifo-violation' as const,
          message: `FIFO violation detected on channel ${channel}: Message at index ${i} (ts=${queue[i].timestamp}) sent before head message (ts=${headMessage.timestamp})`,
          details: {
            channel,
            expectedMessage: queue[i], // Should have been at head
            actualMessage: headMessage,
            queueState: [...queue],
          },
        };
      }
    }

    // Verify the message we're about to receive is indeed the head
    if (messageToReceive.id !== headMessage.id) {
      return {
        type: 'fifo-violation' as const,
        message: `FIFO violation: Attempting to receive message ${messageToReceive.id} but head of queue is ${headMessage.id}`,
        details: {
          channel,
          expectedMessage: headMessage,
          actualMessage: messageToReceive,
          queueState: [...queue],
        },
      };
    }

    return undefined; // No violation
  }

  /**
   * Run to completion (or until deadlock/maxSteps)
   */
  run(): CFSMRunResult {
    while (!this.completed && !this.reachedMaxSteps) {
      const result = this.step();

      if (!result.success) {
        return {
          success: false,
          steps: this.stepCount,
          state: this.getState(),
          trace: this.config.recordTrace ? this.trace : undefined,
          error: result.error,
        };
      }
    }

    return {
      success: this.completed,
      steps: this.stepCount,
      state: this.getState(),
      trace: this.config.recordTrace ? this.trace : undefined,
    };
  }

  /**
   * Check if completed
   */
  isComplete(): boolean {
    return this.completed;
  }

  /**
   * Get execution trace
   */
  getTrace(): CFSMExecutionTrace {
    return {
      ...this.trace,
      events: [...this.trace.events],
      totalSteps: this.stepCount,
    };
  }

  /**
   * Reset to initial state
   */
  reset(): void {
    this.currentState = this.cfsm.initialState;
    this.visitedStates = [this.cfsm.initialState];
    this.stepCount = 0;
    this.completed = false;
    this.reachedMaxSteps = false;
    this.buffer = { channels: new Map() };
    this.outgoingMessages = [];
    this.pendingTransitionChoice = null;
    this.messageIdCounter = 0;

    this.trace = {
      role: this.cfsm.role,
      events: [],
      startTime: Date.now(),
      totalSteps: 0,
      completed: false,
    };

    // Clear execution history
    this.executionHistory.clear();

    // Record initial snapshot
    this.recordSnapshot();
  }

  // ============================================================================
  // Execution History & Stepping Debugger
  // ============================================================================

  /**
   * Record current execution state as a snapshot
   */
  private recordSnapshot(): void {
    const snapshot: CFSMExecutionSnapshot = {
      stepNumber: this.stepCount,
      currentState: this.currentState,
      visitedStates: [...this.visitedStates],
      buffer: this.cloneBuffer(),
      outgoingMessages: [...this.outgoingMessages],
      pendingTransitionChoice: this.pendingTransitionChoice,
      completed: this.completed,
      reachedMaxSteps: this.reachedMaxSteps,
      messageIdCounter: this.messageIdCounter,
      timestamp: Date.now(),
    };

    this.executionHistory.recordSnapshot(snapshot);
  }

  /**
   * Restore execution state from a snapshot
   */
  private restoreSnapshot(snapshot: CFSMExecutionSnapshot): void {
    this.stepCount = snapshot.stepNumber;
    this.currentState = snapshot.currentState;
    this.visitedStates = [...snapshot.visitedStates];
    this.buffer = this.cloneBuffer(snapshot.buffer);
    this.outgoingMessages = [...snapshot.outgoingMessages];
    this.pendingTransitionChoice = snapshot.pendingTransitionChoice;
    this.completed = snapshot.completed;
    this.reachedMaxSteps = snapshot.reachedMaxSteps;
    this.messageIdCounter = snapshot.messageIdCounter;
  }

  /**
   * Step forward (explicit stepping)
   * Same as step() but emits step-forward event
   */
  stepForward(): CFSMStepResult {
    this.emit('step-forward', { stepCount: this.stepCount });
    const result = this.step();

    // Record snapshot after successful step
    if (result.success) {
      this.recordSnapshot();
    }

    return result;
  }

  /**
   * Step backward (undo last step)
   * Restores previous execution state from history
   */
  stepBackward(): CFSMStepResult {
    const previousSnapshot = this.executionHistory.getPreviousSnapshot();

    if (!previousSnapshot) {
      const error = {
        type: 'invalid-state' as const,
        message: 'No previous state available in history',
        stateId: this.currentState,
      };
      this.emit('error', error);
      return {
        success: false,
        error,
        state: this.getState(),
      };
    }

    // Restore state
    this.restoreSnapshot(previousSnapshot);

    // Emit step-back event
    this.emit('step-back', {
      stepCount: this.stepCount,
      restoredState: this.getState(),
    });

    return {
      success: true,
      state: this.getState(),
    };
  }

  /**
   * Step into (for consistency with CFG simulator)
   * In CFSM context, this is the same as stepForward since there are no sub-protocols at this level
   */
  stepInto(): CFSMStepResult {
    this.emit('step-into', { stepCount: this.stepCount });
    return this.stepForward();
  }

  /**
   * Step out (for consistency with CFG simulator)
   * In CFSM context, this is the same as stepForward since there are no sub-protocols at this level
   */
  stepOut(): CFSMStepResult {
    this.emit('step-out', { stepCount: this.stepCount });
    return this.stepForward();
  }

  /**
   * Enable execution history tracking
   */
  enableHistory(): void {
    if (this.executionHistory instanceof CFSMExecutionHistory) {
      this.executionHistory.enable();
    }
  }

  /**
   * Disable execution history tracking
   */
  disableHistory(): void {
    if (this.executionHistory instanceof CFSMExecutionHistory) {
      this.executionHistory.disable();
    }
  }

  /**
   * Get execution history
   */
  getExecutionHistory(): ICFSMExecutionHistory {
    return this.executionHistory;
  }

  /**
   * Subscribe to events
   */
  on(event: CFSMEventType, callback: CFSMEventCallback): () => void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event)!.add(callback);

    return () => {
      this.listeners.get(event)?.delete(callback);
    };
  }

  /**
   * Unsubscribe from events
   */
  off(event: CFSMEventType, callback: CFSMEventCallback): void {
    this.listeners.get(event)?.delete(callback);
  }

  /**
   * Emit event
   */
  private emit(event: CFSMEventType, data?: any): void {
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      for (const callback of callbacks) {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in CFSM event callback for '${event}':`, error);
        }
      }
    }
  }

  /**
   * Clone buffer for state snapshot
   */
  private cloneBuffer(buffer?: MessageBuffer): MessageBuffer {
    const sourceBuffer = buffer || this.buffer;
    const cloned: MessageBuffer = { channels: new Map() };
    for (const [from, queue] of sourceBuffer.channels) {
      cloned.channels.set(from, [...queue]);
    }
    return cloned;
  }
}
