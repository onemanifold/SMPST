/**
 * CFSM Simulator - Single Role Execution
 *
 * Implements local execution semantics for one CFSM (one role's view).
 * Based on LTS (Labeled Transition System) semantics for communicating automata.
 *
 * ============================================================================
 * FORMAL SEMANTICS
 * ============================================================================
 *
 * A CFSM is a tuple (Q, q₀, A, →, Q_f) where:
 * - Q: finite set of states
 * - q₀: initial state
 * - A: set of actions (send !p⟨l⟩, receive ?p⟨l⟩, tau τ, choice)
 * - →: transition relation Q × A × Q
 * - Q_f: final states
 *
 * Transition Enabling Rules:
 * 1. Send !p⟨l⟩: Always enabled (async send)
 * 2. Receive ?p⟨l⟩: Enabled iff message ⟨p,l⟩ in buffer
 * 3. Tau τ: Always enabled (internal action)
 * 4. Choice: Always enabled (internal decision)
 *
 * Message Buffers:
 * - One FIFO queue per sender role
 * - Messages consumed in order (FIFO semantics)
 *
 * References:
 * - Honda, Yoshida, Carbone (2008): Multiparty Asynchronous Session Types
 * - Brand & Zafiropulo (1983): On Communicating Finite-State Machines
 */

import type { CFSM, CFSMTransition } from '../projection/types';
import type {
  CFSMSimulatorConfig,
  CFSMExecutionState,
  CFSMStepResult,
  CFSMRunResult,
  Message,
  MessageBuffer,
  CFSMExecutionTrace,
  CFSMTraceEvent,
  CFSMEventType,
  CFSMEventCallback,
  CFSMExecutionSnapshot,
  CFSMExecutionHistoryConfig,
  ICFSMExecutionHistory,
  CallStackFrame,
} from './cfsm-simulator-types';
import { CFSMExecutionHistory } from './execution-history';

export class CFSMSimulator {
  private rootCFSM: CFSM;  // Root CFSM (never changes)
  private config: Required<Omit<CFSMSimulatorConfig, 'executionHistory' | 'transport' | 'cfsmRegistry'>>;

  // Execution history (for backward stepping)
  private executionHistory: ICFSMExecutionHistory;

  // Message transport (optional - for decentralized execution)
  private transport?: any; // MessageTransport from runtime/types

  // CFSM registry for sub-protocol execution
  // Maps protocol name → (role → CFSM)
  private cfsmRegistry: Map<string, Map<string, CFSM>>;

  // Call stack for sub-protocol execution
  // Empty = executing root protocol
  // Non-empty = executing sub-protocol(s)
  // Each frame represents a PARENT context to return to
  private callStack: CallStackFrame[] = [];

  // Current CFSM being executed
  // If callStack empty: this is rootCFSM
  // If callStack non-empty: this is the sub-protocol's CFSM
  private currentCFSM: CFSM;

  // Execution state
  private currentState: string;
  private visitedStates: string[] = [];
  private stepCount: number = 0;
  private completed: boolean = false;
  private reachedMaxSteps: boolean = false;

  // Message buffer (from-role → messages)
  // Used only in legacy mode (no transport)
  private buffer: MessageBuffer = { channels: new Map() };

  // Outgoing messages (generated by sends, to be delivered by coordinator)
  // Used only in legacy mode (no transport)
  private outgoingMessages: Message[] = [];

  // Transition selection
  private pendingTransitionChoice: number | null = null;

  // Trace
  private trace: CFSMExecutionTrace;

  // Event subscribers
  private listeners: Map<CFSMEventType, Set<CFSMEventCallback>> = new Map();

  // Message ID counter
  private messageIdCounter: number = 0;

  constructor(cfsm: CFSM, config: CFSMSimulatorConfig = {}) {
    // Store root CFSM
    this.rootCFSM = cfsm;

    // Initialize current CFSM (starts at root)
    this.currentCFSM = cfsm;

    // Initialize config
    this.config = {
      maxSteps: config.maxSteps ?? 1000,
      maxBufferSize: config.maxBufferSize ?? 0, // 0 = unbounded
      recordTrace: config.recordTrace ?? false,
      transitionStrategy: config.transitionStrategy ?? 'first',
      verifyFIFO: config.verifyFIFO ?? false,
    };

    // Initialize execution history
    this.executionHistory = config.executionHistory || new CFSMExecutionHistory({
      enabled: false, // Disabled by default for performance
      maxSnapshots: 1000,
    });

    // Store transport if provided
    this.transport = config.transport;

    // Initialize CFSM registry for sub-protocol support
    this.cfsmRegistry = config.cfsmRegistry || new Map();

    // Initialize call stack (empty = root protocol)
    this.callStack = [];

    // Initialize at initial state
    this.currentState = cfsm.initialState;
    this.visitedStates.push(cfsm.initialState);

    // Initialize trace
    this.trace = {
      role: cfsm.role,
      events: [],
      startTime: Date.now(),
      totalSteps: 0,
      completed: false,
    };

    // Record initial snapshot
    this.recordSnapshot();
  }

  /**
   * Get current execution state
   */
  getState(): CFSMExecutionState {
    return {
      currentState: this.currentState,
      visitedStates: [...this.visitedStates],
      stepCount: this.stepCount,
      completed: this.completed,
      reachedMaxSteps: this.reachedMaxSteps,
      buffer: this.cloneBuffer(),
      enabledTransitions: this.getEnabledTransitions(),
      pendingTransitionChoice: this.pendingTransitionChoice,
      callStack: [...this.callStack],  // Include call stack in state
    };
  }

  /**
   * Get enabled transitions from current state
   *
   * A transition is enabled if:
   * - Send: Always (asynchronous)
   * - Receive: Message available in buffer/transport
   * - Tau: Always
   * - Choice: Always
   * - SubProtocol: Always (invocation check happens at execution)
   */
  getEnabledTransitions(): CFSMTransition[] {
    const transitions = this.currentCFSM.transitions.filter(t => t.from === this.currentState);

    return transitions.filter(t => {
      if (t.action.type === 'receive') {
        const from = t.action.from;
        const label = t.action.label;

        if (this.transport) {
          // Transport mode: check if any message available for this role
          // Note: We can't peek at message label without consuming it,
          // so we just check if ANY message is available
          // The actual label matching happens during execution
          return this.transport.hasMessage(this.rootCFSM.role);
        } else {
          // Legacy mode: check buffer
          const queue = this.buffer.channels.get(from);
          if (!queue || queue.length === 0) return false;

          // Check if first message matches (FIFO)
          const firstMsg = queue[0];
          return firstMsg.label === label;
        }
      }

      // Send, tau, choice always enabled
      return true;
    });
  }

  /**
   * Execute one step (fire one enabled transition)
   * Now fully async to support async message transport
   */
  async step(): Promise<CFSMStepResult> {
    this.emit('step-start', { stepCount: this.stepCount, currentState: this.currentState });

    // Check if completed
    if (this.completed) {
      const error = {
        type: 'invalid-state' as const,
        message: 'CFSM already completed',
        stateId: this.currentState,
      };
      this.emit('error', error);
      return { success: false, error, state: this.getState() };
    }

    // Check max steps
    if (this.stepCount >= this.config.maxSteps) {
      this.reachedMaxSteps = true;
      const error = {
        type: 'max-steps' as const,
        message: `Maximum steps (${this.config.maxSteps}) reached`,
        stateId: this.currentState,
      };
      this.emit('error', error);
      return { success: false, error, state: this.getState() };
    }

    // Get enabled transitions
    const enabled = this.getEnabledTransitions();

    if (enabled.length === 0) {
      // No enabled transitions - check if terminal or deadlock
      if (this.currentCFSM.terminalStates.includes(this.currentState)) {
        // Reached terminal state

        // Rule [RETURN]: If in sub-protocol, pop from call stack and return to parent
        if (this.callStack.length > 0) {
          const frame = this.callStack.pop()!;

          // Emit step-out event
          this.emit('step-out', {
            protocol: frame.protocol,
            depth: this.callStack.length,  // Depth after popping
          });

          // Return to parent CFSM and state
          this.currentCFSM = frame.parentCFSM;
          this.currentState = frame.returnState;
          this.visitedStates.push(this.currentState);

          // Continue execution in parent context
          // Don't increment stepCount here - the return is part of the sub-protocol step
          return { success: true, state: this.getState() };
        }

        // Root protocol completed
        this.completed = true;
        this.trace.completed = true;
        this.trace.endTime = Date.now();
        this.trace.totalSteps = this.stepCount;
        this.emit('complete', { role: this.rootCFSM.role, steps: this.stepCount });
        return { success: true, state: this.getState() };
      } else {
        // Deadlock - no transitions enabled and not terminal
        const error = {
          type: 'no-enabled-transitions' as const,
          message: `No enabled transitions at state ${this.currentState}`,
          stateId: this.currentState,
        };
        this.emit('deadlock', { role: this.rootCFSM.role, state: this.currentState });
        return { success: false, error, state: this.getState() };
      }
    }

    // Select transition to fire
    let transitionIndex: number;
    if (this.pendingTransitionChoice !== null) {
      transitionIndex = this.pendingTransitionChoice;
      this.pendingTransitionChoice = null;
    } else {
      // Auto-select based on strategy
      if (this.config.transitionStrategy === 'first') {
        transitionIndex = 0;
      } else if (this.config.transitionStrategy === 'random') {
        transitionIndex = Math.floor(Math.random() * enabled.length);
      } else {
        // Manual - require explicit selection
        const error = {
          type: 'transition-required' as const,
          message: 'Multiple transitions enabled - must call selectTransition()',
          stateId: this.currentState,
        };
        return { success: false, error, state: this.getState() };
      }
    }

    if (transitionIndex >= enabled.length) {
      const error = {
        type: 'invalid-state' as const,
        message: `Invalid transition index ${transitionIndex}`,
        stateId: this.currentState,
      };
      return { success: false, error, state: this.getState() };
    }

    const transition = enabled[transitionIndex];

    // Fire the transition
    this.stepCount++;
    const result = await this.fireTransition(transition);

    this.emit('step-end', { stepCount: this.stepCount, result, state: this.getState() });

    return result;
  }

  /**
   * Fire a specific transition
   */
  private async fireTransition(transition: CFSMTransition): Promise<CFSMStepResult> {
    const action = transition.action;

    // Emit transition-fired event
    this.emit('transition-fired', {
      transitionId: transition.id,
      from: transition.from,
      to: transition.to,
      action,
    });

    // Execute action
    switch (action.type) {
      case 'send':
        return await this.executeSend(transition);
      case 'receive':
        return await this.executeReceive(transition);
      case 'tau':
        return this.executeTau(transition);
      case 'choice':
        return this.executeChoice(transition);
      case 'subprotocol':
        return this.executeSubProtocol(transition);
      default:
        throw new Error(`Unknown action type: ${(action as any).type}`);
    }
  }

  /**
   * Execute send action
   * Creates message and sends via transport (if available) or outgoing queue (legacy)
   */
  private async executeSend(transition: CFSMTransition): Promise<CFSMStepResult> {
    const action = transition.action;
    if (action.type !== 'send') throw new Error('Expected send action');

    // Create message(s)
    const recipients = typeof action.to === 'string' ? [action.to] : action.to;
    const messages: Message[] = recipients.map(to => ({
      id: `${this.rootCFSM.role}-msg-${this.messageIdCounter++}`,
      from: this.rootCFSM.role,
      to,
      label: action.label,
      payloadType: action.payloadType,
      timestamp: Date.now(),
    }));

    if (this.transport) {
      // Transport mode: send directly via transport
      for (const msg of messages) {
        // Await transport send - ensures delivery happens before continuing
        await this.transport.send(msg);
      }
    } else {
      // Legacy mode: add to outgoing queue (coordinator will deliver)
      this.outgoingMessages.push(...messages);
    }

    // Emit send event
    for (const msg of messages) {
      this.emit('send', {
        messageId: msg.id,
        to: msg.to,
        label: msg.label,
        payloadType: msg.payloadType,
      });

      // Record in trace
      if (this.config.recordTrace) {
        this.trace.events.push({
          type: 'send',
          timestamp: msg.timestamp,
          to: msg.to,
          label: msg.label,
          payloadType: msg.payloadType,
          messageId: msg.id,
          stateId: this.currentState,
        });
      }
    }

    // Transition to next state
    this.currentState = transition.to;
    this.visitedStates.push(this.currentState);

    // Check if reached terminal
    if (this.currentCFSM.terminalStates.includes(this.currentState)) {
      this.completed = true;
      this.trace.completed = true;
      this.trace.endTime = Date.now();
      this.trace.totalSteps = this.stepCount;
      this.emit('complete', { role: this.rootCFSM.role, steps: this.stepCount });
    }

    return {
      success: true,
      transition,
      action,
      state: this.getState(),
    };
  }

  /**
   * Execute receive action
   * Consumes message from transport or buffer (legacy)
   */
  private async executeReceive(transition: CFSMTransition): Promise<CFSMStepResult> {
    const action = transition.action;
    if (action.type !== 'receive') throw new Error('Expected receive action');

    let msg: Message;

    if (this.transport) {
      // Transport mode: receive from transport asynchronously
      const receivedMsg = await this.transport.receive(this.rootCFSM.role);

      if (!receivedMsg) {
        throw new Error(`No message available from transport for ${this.rootCFSM.role}`);
      }

      msg = receivedMsg;

      // In transport mode, we trust the transport to maintain FIFO ordering
      // Verification would happen at the transport layer
    } else {
      // Legacy mode: get message from buffer (FIFO)
      const queue = this.buffer.channels.get(action.from);
      if (!queue || queue.length === 0) {
        throw new Error(`No message from ${action.from} in buffer`);
      }

      msg = queue[0]; // Peek at head without removing yet

      // Verify FIFO property (Theorem 5.3, Honda 2016)
      const violation = this.verifyFIFOProperty(action.from, msg);
      if (violation) {
        // FIFO violation detected - return error
        return {
          success: false,
          error: {
            type: 'fifo-violation',
            message: violation.message,
            stateId: this.currentState,
            details: violation.details,
          },
          state: this.getState(),
        };
      }

      // Dequeue message (now safe after verification)
      queue.shift()!;
    }

    // Emit receive event
    this.emit('receive', {
      messageId: msg.id,
      from: msg.from,
      label: msg.label,
      payloadType: msg.payloadType,
    });

    // Emit buffer-dequeue event (only in legacy mode)
    if (!this.transport) {
      const queue = this.buffer.channels.get(action.from);
      this.emit('buffer-dequeue', {
        from: msg.from,
        message: msg,
        remainingInQueue: queue?.length ?? 0,
      });
    }

    // Record in trace
    if (this.config.recordTrace) {
      this.trace.events.push({
        type: 'receive',
        timestamp: Date.now(),
        from: action.from,
        label: action.label,
        payloadType: action.payloadType,
        messageId: msg.id,
        stateId: this.currentState,
      });
    }

    // Transition to next state
    this.currentState = transition.to;
    this.visitedStates.push(this.currentState);

    // Check if reached terminal
    if (this.currentCFSM.terminalStates.includes(this.currentState)) {
      this.completed = true;
      this.trace.completed = true;
      this.trace.endTime = Date.now();
      this.trace.totalSteps = this.stepCount;
      this.emit('complete', { role: this.rootCFSM.role, steps: this.stepCount });
    }

    return {
      success: true,
      transition,
      action,
      state: this.getState(),
    };
  }

  /**
   * Execute tau (silent) action
   */
  private executeTau(transition: CFSMTransition): CFSMStepResult {
    const action = transition.action;
    if (action.type !== 'tau') throw new Error('Expected tau action');

    this.emit('tau', { stateId: this.currentState });

    // Record in trace
    if (this.config.recordTrace) {
      this.trace.events.push({
        type: 'tau',
        timestamp: Date.now(),
        stateId: this.currentState,
      });
    }

    // Transition to next state
    this.currentState = transition.to;
    this.visitedStates.push(this.currentState);

    // Check if reached terminal
    if (this.currentCFSM.terminalStates.includes(this.currentState)) {
      this.completed = true;
      this.trace.completed = true;
      this.trace.endTime = Date.now();
      this.trace.totalSteps = this.stepCount;
      this.emit('complete', { role: this.rootCFSM.role, steps: this.stepCount });
    }

    return {
      success: true,
      transition,
      action,
      state: this.getState(),
    };
  }

  /**
   * Execute choice action
   */
  private executeChoice(transition: CFSMTransition): CFSMStepResult {
    const action = transition.action;
    if (action.type !== 'choice') throw new Error('Expected choice action');

    this.emit('choice', { branch: action.branch, stateId: this.currentState });

    // Record in trace
    if (this.config.recordTrace) {
      this.trace.events.push({
        type: 'choice',
        timestamp: Date.now(),
        branch: action.branch,
        stateId: this.currentState,
      });
    }

    // Transition to next state
    this.currentState = transition.to;
    this.visitedStates.push(this.currentState);

    // Check if reached terminal
    if (this.currentCFSM.terminalStates.includes(this.currentState)) {
      this.completed = true;
      this.trace.completed = true;
      this.trace.endTime = Date.now();
      this.trace.totalSteps = this.stepCount;
      this.emit('complete', { role: this.rootCFSM.role, steps: this.stepCount });
    }

    return {
      success: true,
      transition,
      action,
      state: this.getState(),
    };
  }

  /**
   * Execute sub-protocol invocation
   * Follows formal semantics: Rule [CALL] from docs/SUB_PROTOCOL_FORMAL_SEMANTICS.md
   *
   * Pushes current context onto call stack and transitions to sub-protocol
   */
  private executeSubProtocol(transition: CFSMTransition): CFSMStepResult {
    const action = transition.action;
    if (action.type !== 'subprotocol') throw new Error('Expected subprotocol action');

    // Look up sub-protocol CFSM from registry
    const protocolCFSMs = this.cfsmRegistry.get(action.protocol);
    if (!protocolCFSMs) {
      const error = {
        type: 'invalid-state' as const,
        message: `Sub-protocol '${action.protocol}' not found in registry`,
        stateId: this.currentState,
      };
      return { success: false, error, state: this.getState() };
    }

    // Map this role to the sub-protocol's formal parameter using role mapping
    // The roleMapping maps: formalRole → actualRole (e.g., {Client: 'Alice', Server: 'Bob'})
    // We need to find which formal role corresponds to this executor's actual role
    const formalRole = Object.entries(action.roleMapping)
      .find(([formal, actual]) => actual === this.rootCFSM.role)?.[0];

    if (!formalRole) {
      const error = {
        type: 'invalid-state' as const,
        message: `Role '${this.rootCFSM.role}' not found in role mapping for sub-protocol '${action.protocol}'`,
        stateId: this.currentState,
      };
      return { success: false, error, state: this.getState() };
    }

    // Get the CFSM for the formal role in the sub-protocol
    const subProtocolCFSM = protocolCFSMs.get(formalRole);
    if (!subProtocolCFSM) {
      const error = {
        type: 'invalid-state' as const,
        message: `CFSM for role '${formalRole}' not found in sub-protocol '${action.protocol}'`,
        stateId: this.currentState,
      };
      return { success: false, error, state: this.getState() };
    }

    // Create call stack frame for parent context
    const frame: CallStackFrame = {
      parentCFSM: this.currentCFSM,        // Current CFSM becomes parent
      returnState: action.returnState,      // Where to return after sub-protocol completes
      roleMapping: action.roleMapping,
      protocol: action.protocol,
    };

    // Push parent frame onto call stack
    this.callStack.push(frame);

    // Switch to sub-protocol execution context
    this.currentCFSM = subProtocolCFSM;
    this.currentState = subProtocolCFSM.initialState;
    this.visitedStates.push(this.currentState);

    // Emit step-into event
    this.emit('step-into', {
      protocol: action.protocol,
      depth: this.callStack.length,
      roleMapping: action.roleMapping,
    });

    // Record in trace
    if (this.config.recordTrace) {
      this.trace.events.push({
        type: 'subprotocol-call',
        timestamp: Date.now(),
        protocol: action.protocol,
        stateId: this.currentState,
      } as any);  // TODO: Add proper trace event type
    }

    return {
      success: true,
      transition,
      action,
      state: this.getState(),
    };
  }

  /**
   * Deliver a message to this simulator's buffer
   * Called by distributed coordinator
   *
   * FIFO Semantics (Theorem 5.3, Honda 2016):
   * Messages are enqueued using push() to maintain send order.
   * The queue is FIFO: first message in is first message out.
   */
  deliverMessage(message: Message): void {
    const from = message.from;

    // Check buffer size limit
    if (this.config.maxBufferSize > 0) {
      const queue = this.buffer.channels.get(from) || [];
      if (queue.length >= this.config.maxBufferSize) {
        throw new Error(`Buffer overflow: ${this.rootCFSM.role} cannot accept message from ${from}`);
      }
    }

    // Add to buffer (maintains FIFO: push to end, shift from start)
    if (!this.buffer.channels.has(from)) {
      this.buffer.channels.set(from, []);
    }
    this.buffer.channels.get(from)!.push(message);

    this.emit('buffer-enqueue', {
      from,
      message,
      queueLength: this.buffer.channels.get(from)!.length,
    });
  }

  /**
   * Get outgoing messages (sent but not yet delivered)
   * Called by distributed coordinator
   */
  getOutgoingMessages(): Message[] {
    const messages = [...this.outgoingMessages];
    this.outgoingMessages = []; // Clear after reading
    return messages;
  }

  /**
   * Select transition manually (for manual strategy)
   */
  selectTransition(index: number): void {
    const enabled = this.getEnabledTransitions();
    if (index < 0 || index >= enabled.length) {
      throw new Error(`Invalid transition index ${index} (${enabled.length} enabled)`);
    }
    this.pendingTransitionChoice = index;
  }

  /**
   * Verify FIFO ordering property (Theorem 5.3, Honda et al. 2016)
   *
   * Theorem 5.3: For all messages (mᵢ, mⱼ) in queue Q_{p → q}:
   *   i < j ⟹ receive(mᵢ) ≺ receive(mⱼ)
   *
   * Property: Messages from sender p to receiver q must be received
   * in the exact order they were sent.
   *
   * @param channel - Sender role
   * @param messageToReceive - Message about to be received
   * @returns Violation details if FIFO violated, undefined otherwise
   */
  private verifyFIFOProperty(channel: string, messageToReceive: Message): { type: 'fifo-violation'; message: string; details: any } | undefined {
    if (!this.config.verifyFIFO) {
      return undefined; // Verification disabled
    }

    const queue = this.buffer.channels.get(channel);
    if (!queue || queue.length === 0) {
      return undefined; // Empty queue, no violation possible
    }

    // Theorem 5.3 verification:
    // The message at the head of the queue (index 0) must be the oldest (lowest timestamp)
    const headMessage = queue[0];

    // Verify that headMessage is indeed the oldest in the queue
    for (let i = 1; i < queue.length; i++) {
      if (queue[i].timestamp < headMessage.timestamp) {
        // VIOLATION: A newer message (at index i) has an earlier timestamp
        // This violates FIFO ordering
        return {
          type: 'fifo-violation' as const,
          message: `FIFO violation detected on channel ${channel}: Message at index ${i} (ts=${queue[i].timestamp}) sent before head message (ts=${headMessage.timestamp})`,
          details: {
            channel,
            expectedMessage: queue[i], // Should have been at head
            actualMessage: headMessage,
            queueState: [...queue],
          },
        };
      }
    }

    // Verify the message we're about to receive is indeed the head
    if (messageToReceive.id !== headMessage.id) {
      return {
        type: 'fifo-violation' as const,
        message: `FIFO violation: Attempting to receive message ${messageToReceive.id} but head of queue is ${headMessage.id}`,
        details: {
          channel,
          expectedMessage: headMessage,
          actualMessage: messageToReceive,
          queueState: [...queue],
        },
      };
    }

    return undefined; // No violation
  }

  /**
   * Run to completion (or until deadlock/maxSteps)
   */
  async run(): Promise<CFSMRunResult> {
    while (!this.completed && !this.reachedMaxSteps) {
      const result = await this.step();

      if (!result.success) {
        return {
          success: false,
          steps: this.stepCount,
          state: this.getState(),
          trace: this.config.recordTrace ? this.trace : undefined,
          error: result.error,
        };
      }
    }

    return {
      success: this.completed,
      steps: this.stepCount,
      state: this.getState(),
      trace: this.config.recordTrace ? this.trace : undefined,
    };
  }

  /**
   * Check if completed
   */
  isComplete(): boolean {
    return this.completed;
  }

  /**
   * Get execution trace
   */
  getTrace(): CFSMExecutionTrace {
    return {
      ...this.trace,
      events: [...this.trace.events],
      totalSteps: this.stepCount,
    };
  }

  /**
   * Reset to initial state
   */
  reset(): void {
    // Reset to root CFSM
    this.currentCFSM = this.rootCFSM;
    this.callStack = [];

    // Reset state
    this.currentState = this.rootCFSM.initialState;
    this.visitedStates = [this.rootCFSM.initialState];
    this.stepCount = 0;
    this.completed = false;
    this.reachedMaxSteps = false;
    this.buffer = { channels: new Map() };
    this.outgoingMessages = [];
    this.pendingTransitionChoice = null;
    this.messageIdCounter = 0;

    this.trace = {
      role: this.rootCFSM.role,
      events: [],
      startTime: Date.now(),
      totalSteps: 0,
      completed: false,
    };

    // Clear execution history
    this.executionHistory.clear();

    // Record initial snapshot
    this.recordSnapshot();
  }

  // ============================================================================
  // Execution History & Stepping Debugger
  // ============================================================================

  /**
   * Record current execution state as a snapshot
   */
  private recordSnapshot(): void {
    const snapshot: CFSMExecutionSnapshot = {
      stepNumber: this.stepCount,
      currentState: this.currentState,
      visitedStates: [...this.visitedStates],
      buffer: this.cloneBuffer(),
      outgoingMessages: [...this.outgoingMessages],
      pendingTransitionChoice: this.pendingTransitionChoice,
      completed: this.completed,
      reachedMaxSteps: this.reachedMaxSteps,
      messageIdCounter: this.messageIdCounter,
      timestamp: Date.now(),
    };

    this.executionHistory.recordSnapshot(snapshot);
  }

  /**
   * Restore execution state from a snapshot
   */
  private restoreSnapshot(snapshot: CFSMExecutionSnapshot): void {
    this.stepCount = snapshot.stepNumber;
    this.currentState = snapshot.currentState;
    this.visitedStates = [...snapshot.visitedStates];
    this.buffer = this.cloneBuffer(snapshot.buffer);
    this.outgoingMessages = [...snapshot.outgoingMessages];
    this.pendingTransitionChoice = snapshot.pendingTransitionChoice;
    this.completed = snapshot.completed;
    this.reachedMaxSteps = snapshot.reachedMaxSteps;
    this.messageIdCounter = snapshot.messageIdCounter;
  }

  /**
   * Step forward (explicit stepping)
   * Same as step() but emits step-forward event
   */
  async stepForward(): Promise<CFSMStepResult> {
    this.emit('step-forward', { stepCount: this.stepCount });
    const result = await this.step();

    // Record snapshot after successful step
    if (result.success) {
      this.recordSnapshot();
    }

    return result;
  }

  /**
   * Step backward (undo last step)
   * Restores previous execution state from history
   */
  stepBackward(): CFSMStepResult {
    const previousSnapshot = this.executionHistory.getPreviousSnapshot();

    if (!previousSnapshot) {
      const error = {
        type: 'invalid-state' as const,
        message: 'No previous state available in history',
        stateId: this.currentState,
      };
      this.emit('error', error);
      return {
        success: false,
        error,
        state: this.getState(),
      };
    }

    // Restore state
    this.restoreSnapshot(previousSnapshot);

    // Emit step-back event
    this.emit('step-back', {
      stepCount: this.stepCount,
      restoredState: this.getState(),
    });

    return {
      success: true,
      state: this.getState(),
    };
  }

  /**
   * Step into (for consistency with CFG simulator)
   * In CFSM context, this is the same as stepForward since there are no sub-protocols at this level
   */
  async stepInto(): Promise<CFSMStepResult> {
    this.emit('step-into', { stepCount: this.stepCount });
    return await this.stepForward();
  }

  /**
   * Step out (for consistency with CFG simulator)
   * In CFSM context, this is the same as stepForward since there are no sub-protocols at this level
   */
  async stepOut(): Promise<CFSMStepResult> {
    this.emit('step-out', { stepCount: this.stepCount });
    return await this.stepForward();
  }

  /**
   * Enable execution history tracking
   */
  enableHistory(): void {
    if (this.executionHistory instanceof CFSMExecutionHistory) {
      this.executionHistory.enable();
    }
  }

  /**
   * Disable execution history tracking
   */
  disableHistory(): void {
    if (this.executionHistory instanceof CFSMExecutionHistory) {
      this.executionHistory.disable();
    }
  }

  /**
   * Get execution history
   */
  getExecutionHistory(): ICFSMExecutionHistory {
    return this.executionHistory;
  }

  /**
   * Subscribe to events
   */
  on(event: CFSMEventType, callback: CFSMEventCallback): () => void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event)!.add(callback);

    return () => {
      this.listeners.get(event)?.delete(callback);
    };
  }

  /**
   * Unsubscribe from events
   */
  off(event: CFSMEventType, callback: CFSMEventCallback): void {
    this.listeners.get(event)?.delete(callback);
  }

  /**
   * Emit event
   */
  private emit(event: CFSMEventType, data?: any): void {
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      for (const callback of callbacks) {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in CFSM event callback for '${event}':`, error);
        }
      }
    }
  }

  /**
   * Clone buffer for state snapshot
   */
  private cloneBuffer(buffer?: MessageBuffer): MessageBuffer {
    const sourceBuffer = buffer || this.buffer;
    const cloned: MessageBuffer = { channels: new Map() };
    for (const [from, queue] of sourceBuffer.channels) {
      cloned.channels.set(from, [...queue]);
    }
    return cloned;
  }
}
